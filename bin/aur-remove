#!/usr/bin/env perl
# -*- cperl-indent-level: 4; -*-
use strict;
use warnings;

use Cwd 'abs_path';
use File::Basename;
use File::Copy;
use File::Find;
use File::Temp 'tempfile';

use Getopt::Long;
my $opt_d = 0;
my $opt_h = 0;
my $opt_f = "";
my $opt_t = "";
my $opt_s = 0;
my $opt_c = "/etc/pacman.conf";
my $opt_a = 0;
my $opt_m = 0;

sub usage($) {
    if ($_[0] eq "aur-remove") {
        print STDERR "Usage: $_[0] [--dry] [-f from] [--] pkgname [pkgname...]\n";
    } elsif ($_[0] eq "aur-move") {
        print STDERR "Usage: $_[0] [--dry] [-f from] [-t to] [--] pkgname [pkgname...]\n";
    } elsif ($_[0] eq "aur-add") {
        print STDERR "Usage: $_[0] [--dry] [-t to] [--] package [package...]\n";
    }
    exit(1);
}

# XXX expose repo-add -n/-p (--add)
#     use hash with different options depending on mode/$0
#     use generic name instead of "default" remove mode
#     allow to specify local repo path directly (--root A --root B)
my $argv0 = basename($0);
GetOptions('dryrun|print' => \$opt_d,
           'f|from=s' => \$opt_f,
           'h|help' => \$opt_h,
           't|to=s' => \$opt_t,
           's|sync' => \$opt_s,
           'c|config=s' => \$opt_c,
           'a|add' => \$opt_a,
           'm|move' => \$opt_m)
     or usage($argv0);

usage($argv0)
  if ($opt_h == 1);
$opt_a = 1
  if ($argv0 eq "aur-add");
$opt_m = 1
  if ($argv0 eq "aur-move");

# XXX -t invalid option for aur-remove?
if (length($opt_t) == 0 && $opt_a) {
    print STDERR "--add requires a target (-t) repository\n";
    usage($argv0);
} elsif (length($opt_f) > 0 && $opt_a) {
    print STDERR "--add cannot be used with a source (-f) repository\n";
    usage($argv0);
} elsif (length($opt_t) == 0 && $opt_m == 1) {
    print STDERR "--move requires both a source (-f) and target (-t)\n";
    usage($argv0);
} elsif (length($opt_t) > 1 && length($opt_f) == 0 && $opt_a == 0) {
    print STDERR "--move requires both a source (-f) and target (-t)\n";
    usage($argv0);
} elsif (not -e $opt_c) {
    print STDERR "$opt_c: file is not readable\n";
    exit(1);
}

# https://metacpan.org/source/ZMIJ/Array-Utils-0.5/Utils.pm
sub array_minus(\@\@) {
    my %e = map{ $_ => undef } @{$_[1]};
    return grep( ! exists( $e{$_} ), @{$_[0]} ); 
}

sub local_repo_path($) {
    my $repo = $_[0];
    my $pacman_conf = $opt_c;

    my @list = `pacconf --config=$pacman_conf --repo=$repo Server`
        or die "pacconf: $!";
    my @paths;
    chomp(@list);

    for my $serv(@list) {
        if ($serv =~ /^file:\/\//) {
            $serv =~ s/file:\/\///;
            push(@paths, $serv . "/" . $repo . ".db");
        }
    }
    return @paths;
}

sub local_repo_list() {
    my $pacman_conf = $opt_c;

    my @list = `pacconf --config=$pacman_conf --repo-list`
        or die "pacconf: $!";
    my @list_local;
    chomp @list;

    for my $repo(@list) {
        my @paths = local_repo_path($repo);
        chomp @paths;

        for my $path(@paths) {
            push(@list_local, $path);
        }
    }
    return @list_local;
}

# PKGBUILD(5)
my $pkgspec = qr/((?=[^\-\.])[\w\-@\.\+]+)\-(\d:)?([^:\/\-\s]+)\-(\d+(\.\d+)?)/;
my $pkgfile = qr/${pkgspec}\-(\w+)(\.pkg\.tar)(\.\w+)?/;

sub file_match_pkgname($$) {
    return $_[0] =~ /${pkgfile}$/ && $1 eq $_[1];
}
sub repo_match_pkgname($$) {
    return $_[0] =~ /${pkgspec}$/ && $1 eq $_[1];
}

if ($#ARGV < 0) {
    print STDERR "$0: requires at least one package name\n";
    exit(1);
}

my %packages;
my %removals;
my @repo_list;
my @move_list;
my %to_sync;

if (length($opt_t) > 1) {
    @move_list = local_repo_path($opt_t);
}
if (length($opt_f) > 1) {
    @repo_list = local_repo_path($opt_f);
} else {
    @repo_list = local_repo_list();
}

chomp @repo_list;
chomp @move_list;

die 'no file:// repository found (-f)'
    unless scalar(@repo_list) > 0;
die 'no file:// repository found (-t)'
    unless scalar(@move_list) > 0 or $opt_t eq "";

ADD:
if ($opt_a) { # assumes single repository (--to)
    my @add_list;
    my @add_nval;

    for my $arg(@ARGV) {
        if ($arg =~ /${pkgfile}$/ && (-f $arg)) {
            push(@add_list, $arg);
        } else {
            push(@add_nval, $arg);
        }
    }

    if (scalar(@add_nval) > 0) {
        die "invalid package specified";
    } else {
        for my $pkg(@add_list) {
            my $move_target = dirname($move_list[0]);

            if ($opt_d == 0) {
                if (move($pkg, $move_target)) {
                    system('repo-add', abs_path($move_list[0]), $move_target . "/" . $pkg);

                    my $db_name = basename($move_list[0], ".db");
                    $to_sync{$db_name} = 1;
                } else {
                    warn("warning: could not move $pkg to $move_target\n");
                    warn("warning: repo-add was not run for $pkg\n");
                }
            } else {
                print("[DRY] mv $pkg " . $move_target . "\n");
                print("[DRY] repo-add " . abs_path($move_list[0]) . " " . $pkg . "\n");
            }
        }
        goto DB_UPGRADE;
    }
}

MOVE:
for my $repo(@repo_list) {
    my @contents = `tar -tf $repo --exclude='*/*'`;
    chomp @contents;

    for my $entry(@contents) {
        $entry =~ s/\/$//; # remove trailing backslash

        for my $needle(@ARGV) {
            if (repo_match_pkgname($entry, $needle)) {
                push(@{$removals{$needle}}, abs_path($repo));

                my $db_name = basename($repo, ".db");
                $to_sync{$db_name} = 1
                    unless exists $to_sync{$db_name};
            }
        }
    }
    find(sub {
            return unless -f;
            for my $needle(@ARGV) {
                if (file_match_pkgname($_, $needle)) {
                    push(@{$packages{$needle}}, $File::Find::name); # store full path
                }
            }
        }, dirname($repo)
    );
}
my @keys_r = keys %removals;
my @keys_p = keys %packages;

for(array_minus(@ARGV, @keys_r)) {
    warn("warning: $_ not found in database\n");
}
for(array_minus(@ARGV, @keys_p)) {
    warn("warning: $_ not found in cache\n");
}

MOVE_DISK:
for my $name(@keys_p) {
    for my $file(@{$packages{$name}}) {
        if ($opt_m == 1) {
            # XXX move to multiple repositories?
            my $move_target = dirname($move_list[0]);

            if ($opt_d == 0 && move($file, $move_target)) {
                print("moved $file to " . $move_target . "\n");
            } elsif ($opt_d == 0) {
                warn("warning: could not move $file to $move_target\n");
            } else {
                print("[DRY] mv $file " . dirname($move_list[0]) . "\n");
            }
        } elsif ($opt_d == 0 && unlink $file) {
            print("unlinked $file\n");
        } elsif ($opt_d == 0) {
            warn("warning: could not unlink $file\n");
        } else {
            print("[DRY] unlink $file\n");
        }
    }
}

MOVE_DB:
for my $name(@keys_r) {
    for my $path(@{$removals{$name}}) {
        if ($opt_m == 1) {
            my $target_pkg;
            my @packages;

            if (defined $packages{$name}) {
                @packages = @{$packages{$name}};
            } else {
                die "package list empty";
            }

            if (scalar(@packages) > 1) {
                my ($fh, $filename) = tempfile();
                print $fh join("\n", @packages);

                my @sorted_pkg = `pacsort -r $filename` or die "pacsort: $!";
                chomp(@sorted_pkg);

                close($fh);
                $target_pkg = basename($sorted_pkg[0]);
            } else {
                $target_pkg = basename($packages[0]);
            }
            my $new_path = dirname($move_list[0]) . "/" . $target_pkg;

            if ($opt_d == 0) {
                # XXX only add file if $new_path exists, check repo-add exit status
                system('repo-add', abs_path($move_list[0]), $new_path);
                system('repo-remove', $path, $name);

                $to_sync{basename($move_list[0], ".db")} = 1;
            } else {
                print("[DRY] repo-add " . abs_path($move_list[0]) . " " . $new_path . "\n");
                print("[DRY] repo-remove $path $name\n");
            }
        } elsif ($opt_d == 0) {
            system('repo-remove', $path, $name);
        } else {
            print("[DRY] repo-remove $path $name\n");
        }
    }
}

DB_UPGRADE:
my @keys_s = keys %to_sync;
if ($opt_d == 0 && $opt_s == 0) {
    for my $repo(@keys_s) {
        my $cmd = "pacsync " . $repo;
        print("note: database modified, run '" . $cmd . "' to reflect changes\n");
    }
} elsif ($opt_d == 0) {
    for my $repo(@keys_s) {
        system('sudo', 'pacsync', $repo); # XXX "or" is triggered here, even on correct update
    }
} elsif ($opt_s == 1) {
    for my $repo(@keys_s) {
        print("[DRY] pacsync " . $repo . "\n");
    }
}
