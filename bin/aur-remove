#!/usr/bin/env perl
use strict;
use warnings;

use Cwd 'abs_path';
use File::Basename;
use File::Find;

use Getopt::Long;
my $opt_d = 0;
my $opt_h = 0;
my $opt_r = "";

sub usage() {
    print STDERR "Usage: remove [-d] [-r <repo>] [--] pkgname [pkgname...]\n";
    exit(1);
}
GetOptions('dryrun|print' => \$opt_d, 'database|repo=s' => \$opt_r,
	   'help' => \$opt_h) or usage();
usage() if ($opt_h == 1);

# https://metacpan.org/source/ZMIJ/Array-Utils-0.5/Utils.pm
sub array_minus(\@\@) {
    my %e = map{ $_ => undef } @{$_[1]};
    return grep( ! exists( $e{$_} ), @{$_[0]} ); 
}

# compatibility to aurutils <=2.3
sub repo_23_compat() {
    my @tsv = `aur repo --repo-list` or die;
    my @res;

    for my $line(@tsv) {
        chomp($line);
        my @cols = split(/\t/, $line);

        push @res, "$cols[1]/$cols[0].db";
    }
    return @res;
}

# PKGBUILD(5)
my $pkgspec = qr/((?=[^\-\.])[\w\-@\.\+]+)\-(\d:)?([^:\/\-\s]+)\-(\d(\.\d)?)/;

sub file_match_pkgname($$) {
    return $_[0] =~ /${pkgspec}\-(\w+)(\.pkg\.tar)(\.\w+)?$/ && $1 eq $_[1];
}
sub repo_match_pkgname($$) {
    return $_[0] =~ /${pkgspec}\/$/ && $1 eq $_[1];
}

if ($#ARGV < 0) {
    print STDERR "remove: requires at least one package name\n";
    exit(1);
}

my %packages;
my %removals;
my @repo_list;

if (length($opt_r) > 1) {
    @repo_list = `aur repo -d $opt_r` or die;
} else {
    if (defined $ENV{'AUR_23_COMPAT'}) {
	@repo_list = repo_23_compat();
    } else {
	@repo_list = `aur repo --repo-list` or die;
    }
}
chomp @repo_list;

for my $repo(@repo_list) {
    my @contents = `tar -tf $repo --exclude='*/*'`;
    chomp @contents;

    for my $entry(@contents) {
        # TODO: remove entry from matcher if found (repo can only
        # contain one entry per package name) -> use hash
        for my $needle(@ARGV) {
            if (repo_match_pkgname($entry, $needle)) {
                push(@{$removals{$needle}}, abs_path($repo));
            }
        }
    }
    find(sub {
        return unless -f;

        for my $needle(@ARGV) {
            if (file_match_pkgname($_, $needle)) {
                push(@{$packages{$needle}}, $File::Find::name); # store full path
            }
        }
    }, dirname($repo));
}
my @keys_r = keys %removals;
my @keys_p = keys %packages;

for(array_minus(@ARGV, @keys_r)) {
    warn("warning: $_ not found in database\n");
}
for(array_minus(@ARGV, @keys_p)) {
    warn("warning: $_ not found in cache\n");
}

# Remove repository entries
for my $name(@keys_r) {
    for my $path(@{$removals{$name}}) {
        if ($opt_d == 0) {
            system('repo-remove', $path, $name);
        } else {
            print("[DRY] repo-remove $path $name\n");
        }
    }
}

# TODO: print a command for each changed database (pacsync <foo>, ...)
if (scalar(@keys_r) > 0 && $opt_d == 0) {
    print("note: database modified, run 'pacsync' to reflect changes\n");
}

# Remove package files from disk
for my $name(@keys_p) {
    for my $file(@{$packages{$name}}) {
        if ($opt_d == 0 && unlink $file) {
            print("unlinked $file\n");
        } elsif ($opt_d == 0) {
            warn("warning: could not unlink $file\n");
        } else {
            print("[DRY] unlinked $file\n");
        }
    }
}
