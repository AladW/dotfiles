#!/usr/bin/env perl
use strict;
use warnings;

use Cwd 'abs_path';
use File::Basename;
use File::Find;

use Getopt::Long;
my $opt_d = 0;
my $opt_h = 0;
my $opt_r = "";

sub usage() {
    print STDERR "Usage: remove [-d] [-r <repo>] [--] pkgname [pkgname...]\n";
    exit(1);
}
GetOptions('dryrun|print'    => \$opt_d,
	   'database|repo=s' => \$opt_r,
	   'help'            => \$opt_h)
     or usage();
usage() if ($opt_h == 1);

# https://metacpan.org/source/ZMIJ/Array-Utils-0.5/Utils.pm
sub array_minus(\@\@) {
    my %e = map{ $_ => undef } @{$_[1]};
    return grep( ! exists( $e{$_} ), @{$_[0]} ); 
}

# compatibility to aurutils <=2.3
sub repo_23_compat() {
    my @tsv = `aur repo --repo-list` or die;
    my @res;

    for my $line(@tsv) {
        chomp($line);
        my @cols = split(/\t/, $line);

        push @res, "$cols[1]/$cols[0].db";
    }
    return @res;
}

# PKGBUILD(5)
my $pkgspec = qr/((?=[^\-\.])[\w\-@\.\+]+)\-(\d:)?([^:\/\-\s]+)\-(\d+(\.\d+)?)/;

sub file_match_pkgname($$) {
    return $_[0] =~ /${pkgspec}\-(\w+)(\.pkg\.tar)(\.\w+)?$/ && $1 eq $_[1];
}
sub repo_match_pkgname($$) {
    return $_[0] =~ /${pkgspec}\/$/ && $1 eq $_[1];
}

if ($#ARGV < 0) {
    print STDERR "remove: requires at least one package name\n";
    exit(1);
}

my %packages;
my %removals;
my @repo_list;
my %to_sync;

if (length($opt_r) > 1) {
    @repo_list = `env -u AUR_DBROOT aur repo -d $opt_r` or die;
} else {
    if (defined $ENV{'AUR_23_COMPAT'}) {
        @repo_list = repo_23_compat();
    } else {
        @repo_list = `aur repo --repo-list` or die;
    }
}
chomp @repo_list;

for my $repo(@repo_list) {
    my @contents = `tar -tf $repo --exclude='*/*'`;
    chomp @contents;

    for my $entry(@contents) {
        for my $needle(@ARGV) {
            if (repo_match_pkgname($entry, $needle)) {
              push(@{$removals{$needle}}, abs_path($repo));

              my $db_name = basename($repo, ".db");
              if (!(exists $to_sync{$db_name})) {
                $to_sync{$db_name} = 1;
              }
            }
        }
    }
    find(sub {
            return unless -f;

            for my $needle(@ARGV) {
                if (file_match_pkgname($_, $needle)) {
                    push(@{$packages{$needle}}, $File::Find::name); # store full path
                }
            }
        }, dirname($repo)
    );
}
my @keys_r = keys %removals;
my @keys_p = keys %packages;
my @keys_s = keys %to_sync;

for(array_minus(@ARGV, @keys_r)) {
    warn("warning: $_ not found in database\n");
}
for(array_minus(@ARGV, @keys_p)) {
    warn("warning: $_ not found in cache\n");
}

# Remove repository entries
for my $name(@keys_r) {
    for my $path(@{$removals{$name}}) {
        if ($opt_d == 0) {
            system('repo-remove', $path, $name);
        } else {
            print("[DRY] repo-remove $path $name\n");
        }
    }
}

if ($opt_d == 0) {
     for my $repo(@keys_s) {
	  my $cmd = "pacsync " . $repo;
	  print("note: database modified, run '" . $cmd . "' to reflect changes\n");
     }
}

# Remove package files from disk
for my $name(@keys_p) {
    for my $file(@{$packages{$name}}) {
        if ($opt_d == 0 && unlink $file) {
            print("unlinked $file\n");
        } elsif ($opt_d == 0) {
            warn("warning: could not unlink $file\n");
        } else {
            print("[DRY] unlink $file\n");
        }
    }
}
