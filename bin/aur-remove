#!/usr/bin/env perl
#requires pacman-contrib pacutils pacman
use strict;
use warnings;

use Cwd 'abs_path';
use File::Basename;
use File::Copy;
use File::Find;
use File::Temp 'tempfile';

use Getopt::Long;
my $opt_d = 0;
my $opt_h = 0;
my $opt_f = "";
my $opt_t = "";
my $opt_s = 0;
my $opt_c = "/etc/pacman.conf";
my $opt_a = 0;
my $opt_m = 0;
my $opt_R = 0;

sub usage($) {
    if ($_[0] eq "aur-remove") {
        print STDERR "Usage: $_[0] [--dry] [-f from...] [--] pkgname [pkgname...]\n";
    } elsif ($_[0] eq "aur-move") {
        print STDERR "Usage: $_[0] [--dry] [-f from] [-t to] [--] pkgname [pkgname...]\n";
    } elsif ($_[0] eq "aur-add") {
        print STDERR "Usage: $_[0] [--dry] [-t to] [--] package [package...]\n";
    } elsif ($_[0] eq "aur-reset") {
        print STDERR "Usage: $_[0] [--dry] [-f from...]\n";
    }
    exit(1);
}

# XXX expose repo-add -n/-p (--add)
#     use modes as $1 (git) instead of mode options or basename $0
#     allow to specify local repo path directly (--root <from> --root <to>)
#     allow options to append to arrays where appropriate (--from A --from B)
my $argv0 = basename($0);
GetOptions('dryrun|print' => \$opt_d,
           'f|from=s' => \$opt_f,
           'h|help' => \$opt_h,
           't|to=s' => \$opt_t,
           's|sync' => \$opt_s,
           'c|config=s' => \$opt_c,
           'a|add' => \$opt_a,
           'm|move' => \$opt_m,
           'R|reset' => \$opt_R)
    or usage($argv0);

usage($argv0)
    if ($opt_h == 1);
$opt_a = 1
    if ($argv0 eq "aur-add");
$opt_m = 1
    if ($argv0 eq "aur-move");
$opt_R = 1
    if ($argv0 eq "aur-reset");

# XXX -t invalid option for aur-remove?
if (length($opt_t) == 0 && $opt_a) {
    print STDERR "--add requires a target (-t) repository\n";
    usage($argv0);
} elsif (length($opt_f) == 0 && $opt_R) {
    print STDERR "--reset requires a source (-f) repository\n";
    usage($argv0);
} elsif (length($opt_f) > 0 && $opt_a) {
    print STDERR "--add cannot be used with a source (-f) repository\n";
    usage($argv0);
} elsif (length($opt_t) == 0 && $opt_m == 1) {
    print STDERR "--move requires both a source (-f) and target (-t)\n";
    usage($argv0);
} elsif (length($opt_t) > 0 && length($opt_f) == 0 && $opt_a == 0) {
    print STDERR "--move requires both a source (-f) and target (-t)\n";
    usage($argv0);
} elsif (not -e $opt_c) {
    print STDERR "$opt_c: file is not readable\n";
    exit(1);
}

# https://metacpan.org/source/ZMIJ/Array-Utils-0.5/Utils.pm
sub array_minus(\@\@) {
    my %e = map{ $_ => undef } @{$_[1]};
    return grep( ! exists( $e{$_} ), @{$_[0]} ); 
}

sub local_repo_path($) {
    my $repo = $_[0];
    my $pacman_conf = $opt_c;

    my @list = `pacconf --config=$pacman_conf --repo=$repo Server`
        or die "pacconf: $!";
    my @paths;
    chomp(@list);

    for my $serv(@list) {
        if ($serv =~ /^file:\/\//) {
            $serv =~ s/file:\/\///;
            push(@paths, $serv . "/" . $repo . ".db");
        }
    }
    return @paths;
}

sub local_repo_list() {
    my $pacman_conf = $opt_c;

    my @list = `pacconf --config=$pacman_conf --repo-list`
        or die "pacconf: $!";
    my @list_local;
    chomp @list;

    for my $repo(@list) {
        my @paths = local_repo_path($repo);
        chomp @paths;

        for my $path(@paths) {
            push(@list_local, $path);
        }
    }
    return @list_local;
}

# PKGBUILD(5)
my $pkgspec = qr/((?=[^\-\.])[\w\-@\.\+]+)\-(\d:)?([^:\/\-\s]+)\-(\d+(\.\d+)?)/;
my $pkgfile = qr/${pkgspec}\-(\w+)(\.pkg\.tar)(\.\w+)?/;

sub file_match_pkgname($$) {
    return $_[0] =~ /${pkgfile}$/ && $1 eq $_[1];
}
sub repo_match_pkgname($$) {
    return $_[0] =~ /${pkgspec}$/ && $1 eq $_[1];
}

if ($#ARGV < 0 && not $opt_R) {
    print STDERR "$argv0: requires at least one package name\n";
    exit(1);
}

my %packages;
my %removals;
my @repo_list;
my @move_list;
my %to_sync;

if (length($opt_t) > 1) {
    @move_list = local_repo_path($opt_t);
}
if (length($opt_f) > 1) {
    @repo_list = local_repo_path($opt_f);
} else {
    @repo_list = local_repo_list();
}

chomp @repo_list;
chomp @move_list;

die 'no file:// repository found (-f)'
    unless scalar(@repo_list) > 0;
die 'no file:// repository found (-t)'
    unless scalar(@move_list) > 0 or $opt_t eq "";

if ($opt_a == 1) {
    my @add_list;
    my @add_nval;

    for my $arg (@ARGV) {
        if ($arg =~ /${pkgfile}$/ && (-f $arg)) {
            push(@add_list, $arg);
        } else {
            print STDERR "invalid package: $arg\n";
            push(@add_nval, $arg);
        }
    }
    my $db_name = basename($move_list[0], ".db");
    $to_sync{$db_name} = 0;

    if (scalar(@add_nval) > 0) {
        die "invalid packages specified";
    } else {
        my $abs_path_t = abs_path($move_list[0]);
        for my $pkg (@add_list) {
            my $move_target = dirname($move_list[0]);

            # XXX Support adding a package to multiple repositories?
            if ($opt_d == 0 && move($pkg, $move_target)) {
                if (system('repo-add', $abs_path_t, $move_target . "/" . $pkg) == 0) {
                    $to_sync{$db_name}++;
                } else {
                    print STDERR "repo-add failed: $?\n";
                }
            } elsif ($opt_d == 0) {
                warn("warning: could not move $pkg to $move_target\n");
                warn("warning: repo-add was not run for $pkg\n");
            } elsif ($opt_d == 1) {
                print("[DRY] mv $pkg " . $move_target . "\n");
                print("[DRY] repo-add " . abs_path($move_list[0]) . " " . $pkg . "\n");

                $to_sync{$db_name}++;
            }
        }
    }
} elsif ($opt_R == 1) {
    # Remove the database and create a new copy with newest (vercmp) packages
    my %candidates;

    # XXX support multiple repositories
    find(sub {
        my @match = ($_ =~ /${pkgfile}$/);

        if (scalar(@match) > 0) {
            $candidates{$File::Find::name} = $match[0];
        } else {
            return;
        }
    }, dirname($repo_list[0]));

    my @sorted;
    if (scalar(keys %candidates) > 0) {
        my ($fh, $filename) = tempfile();
        for my $pkg(keys %candidates) {
            print $fh "$pkg\n";
        }

        @sorted = `pacsort -r $filename` or die "pacsort: $!";
        close($fh);
        chomp(@sorted);
    } else {
        die "$argv0: no packages found";
    }
    my %names;
    my @targets;

    for my $pkg(@sorted) {
        my $name = $candidates{$pkg};

        push(@targets, $pkg)
            unless exists $names{$name};
        $names{$name} = 1;
    }
    my $abs_path_f = abs_path($repo_list[0]);

    if ($opt_d == 0 && unlink $abs_path_f) {
        print("unlinked $abs_path_f\n");

        if (system('repo-add', $abs_path_f, @targets) == 0) {
            $to_sync{basename($repo_list[0], ".db")}++;
        } else {
            print STDERR "repo-add failed: $?\n";
        }
    } elsif ($opt_d == 0) {
        warn("warning: could not unlink $abs_path_f\n");
    } elsif ($opt_d == 1) {
        $to_sync{basename($repo_list[0], ".db")}++;

        print("[DRY] unlink $abs_path_f\n");
        print("[DRY] repo-add $abs_path_f " . join(" ", @targets) . "\n");
    }
} else { # XXX "default" remove mode
    for my $repo(@repo_list) {
        my @contents = `tar -tf $repo --exclude='*/*'`;
        chomp @contents;

        for my $entry(@contents) {
            $entry =~ s/\/$//; # remove trailing backslash

            for my $needle(@ARGV) {
                if (repo_match_pkgname($entry, $needle)) {
                    push(@{$removals{$needle}}, $repo);

                    my $db_name = basename($repo, ".db");
                    $to_sync{$db_name} = 0;
                }
            }
        }
        find(sub {
            return unless -f;
            for my $needle(@ARGV) {
                if (file_match_pkgname($_, $needle)) {
                    push(@{$packages{$needle}}, $File::Find::name); # store full path
                }
            }
        }, dirname($repo));
    }
    my @keys_r = keys %removals;
    my @keys_p = keys %packages;

    for(array_minus(@ARGV, @keys_r)) {
        warn("warning: $_ not found in database\n");
    }
    for(array_minus(@ARGV, @keys_p)) {
        warn("warning: $_ not found in cache\n");
    }

    # disk updates
    for my $name(@keys_p) {
        for my $file(@{$packages{$name}}) {
            if ($opt_m == 1) {
                # XXX move to multiple repositories?
                my $move_target = dirname($move_list[0]);

                if ($opt_d == 0 && move($file, $move_target)) {
                    print("moved $file to " . $move_target . "\n");
                } elsif ($opt_d == 0) {
                    warn("warning: could not move $file to $move_target\n");
                } elsif ($opt_d == 1) {
                    print("[DRY] mv $file " . dirname($move_list[0]) . "\n");
                }
            } elsif ($opt_d == 0 && unlink $file) {
                print("unlinked $file\n");
            } elsif ($opt_d == 0) {
                warn("warning: could not unlink $file\n");
            } elsif ($opt_d == 1) {
                print("[DRY] unlink $file\n");
            }
        }
    }

    # database updates
    for my $name(@keys_r) {
        for my $path_f(@{$removals{$name}}) {
            my $abs_path_f = abs_path($path_f); # resolve symbolic link

            if ($opt_m == 1) {
                my $target_pkg;
                my @packages;

                if (defined $packages{$name}) {
                    @packages = @{$packages{$name}};
                } else {
                    die "package list empty";
                }

                if (scalar(@packages) > 1) {
                    my ($fh, $filename) = tempfile();
                    print $fh join("\n", @packages);

                    my @sorted_pkg = `pacsort -r $filename` or die "pacsort: $!";
                    chomp(@sorted_pkg);

                    close($fh);
                    $target_pkg = basename($sorted_pkg[0]);
                } else {
                    $target_pkg = basename($packages[0]);
                }
                my $abs_path_t = abs_path($move_list[0]);
                my $new_path = dirname($move_list[0]) . "/" . $target_pkg;

                if ($opt_d == 0 && (-f $new_path)) {
                    if (system('repo-add', $abs_path_t, $new_path) == 0) {
                        $to_sync{basename($move_list[0], ".db")}++;
                    } else {
                        print STDERR "repo-add failed: $?\n";
                    }

                    if (system('repo-remove', $abs_path_f, $name) == 0) {
                        $to_sync{basename($path_f, ".db")}++;
                    } else {
                        print STDERR "repo-add failed: $?\n";
                    }
                } elsif ($opt_d == 0) {
                    warn("warning: could not find move target $new_path");
                } elsif ($opt_d == 1) {
                    $to_sync{basename($move_list[0], ".db")}++;
                    $to_sync{basename($path_f, ".db")}++;

                    print("[DRY] repo-add $abs_path_t $new_path\n");
                    print("[DRY] repo-remove $abs_path_f $name\n");
                }
            } elsif ($opt_d == 0) { # XXX "default" mode remove
                if (system('repo-remove', $abs_path_f, $name) == 0) {
                    $to_sync{basename($path_f, ".db")}++;
                } else {
                    print STDERR "repo-add failed: $?\n";
                }
            } elsif ($opt_d == 1) {
                print("[DRY] repo-remove $abs_path_f $name\n");
            }
        }
    }
}

my @keys_s;
for my $k(keys %to_sync) {
    if ($to_sync{$k} == 0) {
        print STDERR "repo-add failed for repository $k, ignoring\n";
    } else {
        push(@keys_s, $k);
    }
}
if ($opt_d == 0 && $opt_s == 0) {
    for my $repo(@keys_s) {
        my $cmd = "pacsync " . $repo;
        print("note: database modified, run '" . $cmd . "' to reflect changes\n");
    }
} elsif ($opt_d == 0 && $opt_s == 1) {
    for my $s(@keys_s) {
        system('sudo', 'pacsync', $s);
    }
} elsif ($opt_d == 1 && $opt_s == 1) {
    print("[DRY] pacsync " . join(" ", @keys_s) . "\n");
}
