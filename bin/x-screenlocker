#!/bin/bash
# /usr/share/doc/xss-lock/transfer-sleep-lock-i3lock.sh with i3lock-color and fast blur
sigma=15
i3lock_options=(
    --clock
    --datecolor=ffffffaa
    --timecolor=ffffffff
    --indicator
    --pass-media-keys
    --radius 105
    --ringcolor=ffffff55
    --redraw-thread
)

tmp=$(mktemp -d) || exit
trap 'rm -rf "$tmp"' EXIT

# take a screenshot (root window)
if maim --hidecursor "$tmp"/in.png; then
    # https://github.com/PandorasFox/i3lock-color/issues/129
    if ffmpeg -loglevel 0 -i "$tmp"/in.png -vf "gblur=sigma=$sigma" "$tmp"/out.png; then
        i3lock_options+=(--image="$tmp"/out.png)
    fi
fi

# We set a trap to kill the locker if we get killed, then start the locker and
# wait for it to exit. The waiting is not that straightforward when the locker
# forks, so we use this polling only if we have a sleep lock to deal with.
if [[ -e /dev/fd/${XSS_SLEEP_LOCK_FD:--1} ]]; then
    kill_i3lock() {
        pkill -xu $EUID "$@" i3lock
    }
    trap kill_i3lock TERM INT

    # we have to make sure the locker does not inherit a copy of the lock fd
    i3lock "${i3lock_options[@]}" {XSS_SLEEP_LOCK_FD}<&-

    # now close our fd (only remaining copy) to indicate we're ready to sleep
    exec {XSS_SLEEP_LOCK_FD}<&-

    while kill_i3lock -0; do
        sleep 0.5
    done
else
    trap 'kill %%' TERM INT

    i3lock -n "${i3lock_options[@]}" &
    wait
fi
